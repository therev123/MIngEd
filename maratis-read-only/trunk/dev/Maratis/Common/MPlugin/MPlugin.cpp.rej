--- trunk/dev/Maratis/Common/MPlugin/MPlugin.cpp	(revision 126)
+++ trunk/dev/Maratis/Common/MPlugin/MPlugin.cpp	(working copy)
@@ -30,64 +30,145 @@
 
 #include <MEngine.h>
 #include "MPlugin.h"
+#include <MWindow.h>
+#include <MFileTools.h>
 
+#include <stdio.h>
 
-typedef void * (*FunctionPtr)();
+#ifndef MPLUGIN_DYNAMIC
+#include <map>
+typedef struct _plugin
+{
+  FunctionPtr Start;
+  FunctionPtr End;
+  _plugin() : Start(0), End(0) {}
+  _plugin(FunctionPtr s, FunctionPtr e) : Start(s), End(e) {}
+} plugin;
 
+typedef std::map<const char*, plugin> pluginmap;
+typedef pluginmap::iterator pluginiter;
+pluginmap g_plugindefs;
+
+void AddPluginFunctions(const char* pluginName, FunctionPtr start, FunctionPtr end)
+{
+  plugin p(start, end);
+  g_plugindefs[pluginName] = p;
+}
+#endif
+
+
 MPlugin::MPlugin(void)
 {
+#ifdef MPLUGIN_DYNAMIC
 	m_library = NULL;
+#else
+	Start= 0;
+	End = 0;
+#endif
+	m_loaded = false;
 }
 
 MPlugin::~MPlugin(void)
 {
-	if(m_library)
-	{	
-#ifdef WIN32
-		
-		FunctionPtr function = reinterpret_cast<FunctionPtr>(GetProcAddress(m_library, "EndPlugin"));
-		if(function)
-			 function();
-		FreeLibrary(m_library);
-		
-#else
-		
-		FunctionPtr function = (FunctionPtr)dlsym(m_library, "EndPlugin");
-		if(function)
-			function();
-		dlclose(m_library);
-		
+#ifdef MPLUGIN_DYNAMIC
+    if(m_library)
+    {
+#    ifdef WIN32
+	
+	FunctionPtr function = reinterpret_cast<FunctionPtr>(GetProcAddress(m_library, "EndPlugin"));
+	if(function)
+	    function();
+	FreeLibrary(m_library);
+	
+#    else
+	
+	FunctionPtr function = (FunctionPtr)dlsym(m_library, "EndPlugin");
+	if(function)
+	    function();
+	dlclose(m_library);
+	
+#    endif
+    }
+#else		
+    if(End)
+	End();
 #endif
-	}
 }
 
 void MPlugin::load(const char * filename)
 {
-#ifdef WIN32
+#ifdef MPLUGIN_DYNAMIC
+
+
+	char file[256];
+	MWindow* window = MWindow::getInstance();
+
+	char dirs[3][256];
+	snprintf(dirs[0], 256, window->getWorkingDirectory());
+	snprintf(dirs[1], 256, "%s/Plugins", window->getUserDirectory());
+	snprintf(dirs[2], 256, "%s/Plugins", window->getSystemDirectory());
 	
-    m_library = LoadLibrary(filename);
-    if(! m_library)
-		return;
+	for(int i = 0; i < 3; ++i)
+	{
+#    ifdef WIN32
+	  getGlobalFilename(file, dirs[i], (string(filename) + ".dll").c_str());
+#    elseif __APPLE__
+	  getGlobalFilename(file, dirs[i], (string(filename) + ".dylib").c_str());
+#    else // just assume a linux based os
+	  getGlobalFilename(file, dirs[i], (string(filename) + ".so").c_str());
+#    endif
 
+	  if(isFileExist(file))
+	     break;
+	}
+
+#    ifdef WIN32
+    
+    m_library = LoadLibrary(file);
+    if(! m_library);
+    return;
+    
     FunctionPtr function = reinterpret_cast<FunctionPtr>(GetProcAddress(m_library, "StartPlugin"));
     if(! function)
-		return;
+	return;
 
-	m_filename = filename;
+    m_filename = filename;
+    function();	
+    m_loaded = true;
+
+#    else
+    
+    m_library = dlopen(file, RTLD_LAZY);
+    if(! m_library)
+    {
+	printf("%s\n", dlerror());
+	return;
+    }
+    
+    FunctionPtr function = (FunctionPtr)dlsym(m_library, "StartPlugin");
+    if(! function)
+    {
+	printf(dlerror());
+	return;
+    }
+    
+    m_filename = filename;
     function();
-	
+    m_loaded = true;
+    
+#    endif
 #else
-	
-	m_library = dlopen(filename, RTLD_LAZY);
-	if(! m_library)
-		return;
-	
-	FunctionPtr function = (FunctionPtr)dlsym(m_library, "StartPlugin");
-	if(! function)
-		return;
-	
-	m_filename = filename;
-    function();
-
+    // still need to cut up the filename... or something
+    pluginiter iplug = g_plugindefs.find(filename);
+    if(iplug != g_plugindefs.end())
+    {
+	Start = iplug->second.Start;
+	End = iplug->second.End;
+    }
+    if(Start)
+    {
+        Start();
+	m_loaded = true;
+    }
 #endif
-}+}
