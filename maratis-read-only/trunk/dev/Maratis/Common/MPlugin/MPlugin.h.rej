--- trunk/dev/Maratis/Common/MPlugin/MPlugin.h	(revision 126)
+++ trunk/dev/Maratis/Common/MPlugin/MPlugin.h	(working copy)
@@ -31,33 +31,111 @@
 #ifndef _M_PLUGIN_H
 #define _M_PLUGIN_H
 
-#ifdef WIN32
-#include <windows.h>
-#else
-#include <dlfcn.h>
-#endif
+#ifdef MPLUGIN_DYNAMIC
+#  ifdef WIN32
+#    include <windows.h>
+#    define MPLUGIN_EXPORT __declspec(dllexport)
+#  else
+// automagically exported
+#    define MPLUGIN_EXPORT
+#    include <dlfcn.h>
+#  endif /*WIN32*/
+#endif/*MPLUGIN_DYNAMIC*/
 
-class MPlugin
+typedef void * (*FunctionPtr)();
+
+class M_ENGINE_EXPORT MPlugin
 {
 public :
 
 	MPlugin(void);
 	~MPlugin(void);
 
-private :
+protected :
 
 	string m_filename;
-	
-#ifdef WIN32
-    HMODULE m_library;
+
+#ifdef MPLUGIN_DYNAMIC	
+#    ifdef WIN32
+	HMODULE m_library;
+#    else
+	void * m_library;
+#    endif
 #else
-	void * m_library;
+        FunctionPtr Start;
+        FunctionPtr End;
+
 #endif
-
+	bool m_loaded;
 public:
 	
 	void load(const char * filename);
 	inline const char * getFilename(void){ return m_filename.c_str(); }
+	inline bool isLoaded(void) { return m_loaded; }
 };
 
-#endif+// Some nasty macros to help making plugins for both systems that can dynamically
+// load libraries (ie. sensible systems) and for annoying systems like iOS
+// where we can't have shared objects.
+//
+// to use, in the plugin somewhere do as follows:
+//------------AwesomePlugin.h---------------------------------------------------
+// #include <MPlugin.h>
+// 
+// MPLUGIN_DECLARE(MyAwesomePlugin);
+//------------AwesomePlugin.cpp-------------------------------------------------
+// #include "AwesomePlugin.h"
+//
+// MPLUGIN_START_IMPLEMENT(MyAwesomePlugin)
+// {
+//   // this is where you do your code
+// }
+//
+// MPLUGIN_END_IMPLEMENT(MyAwesomePlugin)
+// {
+//   // cleanup here
+// }
+//
+// Everything else should be taken care of
+
+#ifdef MPLUGIN_DYNAMIC
+#    define MPLUGIN_DECLARE(name)		\
+  extern "C" {					\
+  MPLUGIN_EXPORT void StartPlugin();		\
+  MPLUGIN_EXPORT void EndPlugin();		\
+  }
+
+#    define MPLUGIN_START_IMPLEMENT(name)	\
+  void StartPlugin()
+
+#    define MPLUGIN_END_IMPLEMENT(name)		\
+  void EndPlugin()
+#else
+#    define MPLUGIN_DECLARE(name)			\
+  void StartPlugin##name();				\
+  void EndPlugin##name();				\
+  class Plugin##name##AutoStart				\
+  {							\
+  public:						\
+    Plugin##name##AutoStart();				\
+  }							\
+  extern Plugin##name##AutoStart s_##name##AutoStarter;
+
+#   define MPLUGIN_START_IMPLEMENT(name)				\
+  Plugin##name##AutoStart s_##name##AutoStarter;			\
+  Plugin##name##AutoStart::Plugin##name##AutoStart()			\
+  {									\
+    AddPluginFunctions(#name, &StartPlugin##name, &EndPlugin##name);	\
+  }									\
+  void StartPlugin##name()
+
+#   define MPLUGIN_END_IMPLEMENT(name)		\
+  void EndPlugin##name()
+#endif/*MPLUGIN_DYNAMIC*/
+
+// don't worry about this:
+#ifndef MPLUGIN_DYNAMIC
+void AddPluginFunctions(const char* pluginName, FunctionPtr start, FunctionPtr end);
+#endif
+
+#endif
